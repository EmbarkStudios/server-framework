pub type BoxError = Box<dyn std::error::Error + Sync + Send + 'static>;
pub type BoxBody = http_body::combinators::UnsyncBoxBody<Bytes, axum_core::Error>;
pub type Request<B = BoxBody> = http::Request<B>;
pub type Router<B = BoxBody> = axum::Router<B>;

use bytes::Bytes;
use http::Response;
use tower::{Service, ServiceBuilder};
use tower_http::ServiceBuilderExt;

use server_framework::Server;

pub trait ServerExt {
    /// Add a tonic service to the server.
    ///
    /// ```rust
    /// use axum::async_trait;
    /// use server_framework::Server;
    /// use server_framework_tonic::ServerExt;
    /// #
    /// # #[async_trait]
    /// # trait Greeter {}
    /// # #[derive(Clone)]
    /// # struct GreeterServer<T>(T);
    /// # impl<T> GreeterServer<T> {
    /// #     fn new(t: T) -> Self { Self(t) }
    /// # }
    /// # impl<T> tonic::transport::NamedService for GreeterServer<T> {
    /// #     const NAME: &'static str = "";
    /// # }
    /// # impl<T> tower::Service<http::Request<axum::body::BoxBody>> for GreeterServer<T> {
    /// #     type Response = axum::response::Response;
    /// #     type Error = tonic::codegen::Never;
    /// #     type Future = std::future::Ready<Result<Self::Response, Self::Error>>;
    /// #     fn poll_ready(&mut self, _: &mut std::task::Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
    /// #         todo!()
    /// #     }
    /// #     fn call(&mut self, _: http::Request<axum::body::BoxBody>) -> Self::Future {
    /// #         todo!()
    /// #     }
    /// # }
    ///
    /// #[derive(Clone)]
    /// struct MyGreeter;
    ///
    /// // implement server trait generated by tonic-build
    /// #[async_trait]
    /// impl Greeter for MyGreeter {
    ///     // ...
    /// }
    ///
    /// let service = GreeterServer::new(MyGreeter);
    ///
    /// # async {
    /// Server::default()
    ///     .with_tonic(service)
    ///     .always_live_and_ready()
    ///     .serve()
    ///     .await
    ///     .unwrap();
    /// # };
    /// ```
    fn with_tonic<S, B>(self, service: S) -> Self
    where
        Self: Sized,
        S: Service<Request, Response = Response<B>, Error = tonic::codegen::Never>
            + tonic::transport::NamedService
            + Clone
            + Send
            + 'static,
        S::Future: Send,
        B: http_body::Body<Data = Bytes> + Send + 'static,
        B::Error: Into<BoxError>;
}

impl<F, H> ServerExt for Server<F, H> {
    fn with_tonic<S, B>(self, service: S) -> Self
    where
        Self: Sized,
        S: Service<Request, Response = Response<B>, Error = tonic::codegen::Never>
            + tonic::transport::NamedService
            + Clone
            + Send
            + 'static,
        S::Future: Send,
        B: http_body::Body<Data = Bytes> + Send + 'static,
        B::Error: Into<BoxError>,
    {
        self.with(router_from_tonic(service))
    }
}

/// Convert a [`tonic`] service into a [`Router`].
///
/// This can be useful for composing a number of services and adding middleware to them.
pub fn router_from_tonic<S, B>(service: S) -> Router<BoxBody>
where
    S: Service<Request, Response = Response<B>, Error = tonic::codegen::Never>
        + tonic::transport::NamedService
        + Clone
        + Send
        + 'static,
    S::Future: Send,
    B: http_body::Body<Data = Bytes> + Send + 'static,
    B::Error: Into<BoxError>,
{
    let svc = ServiceBuilder::new()
        .map_err(|err: tonic::codegen::Never| match err {})
        .map_response_body(axum::body::boxed)
        .service(service);
    Router::new().route(&format!("/{}/*rest", S::NAME), svc)
}
